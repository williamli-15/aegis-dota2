# 1) 下载数据

### `download_30k_parsed.py`

# 2) 你们现在先做两件事（顺序固定）

## ✅ Step A：inspect patches + 固化 split（防 leakage）

先确认 JSONL 里 `patch` 的 **唯一值**是不是 3 个（大概率是类似 57/58/59，对应 7.38/7.39/7.40）。

### `aegis/etl/inspect_patches.py`

运行：

```bash
python -m aegis.etl.inspect_patches \
  --input data/raw/matches_parsed_7.38_7.40_v22.jsonl
```

---

## ✅ Step B：生成 splits（Train/Val/Test + 7.40 few-shot curve）

**协议（按我们 PRD）：**

* Train：7.38 + 7.39（其中 7.39 的前 90%）
* Val：7.39 的后 10%（按 start_time 排序）
* Test：7.40 全部
* 再额外输出 `test_calib_N / test_eval_N`（N=25/50/100/200/500/1000）

### `aegis/etl/make_splits.py`

运行（示例：假设 patch id 57/58/59 对应 7.38/7.39/7.40）：

```bash
python -m aegis.etl.make_splits \
  --input data/raw/matches_parsed_7.38_7.40_v22.jsonl \
  --out_dir data/splits \
  --test_patch 59 \
  --val_patch 58 \
  --val_frac 0.1
```

---

# 3) 核心：把 JSONL 落地成 Parquet（events + state snapshots）

你们的 JSONL 每行就是一个 match 对象，所以 ETL 必须 **streaming**（不能一次全读）。

我们输出 6 张表（够训练 + 够评测）：

## 3.1 表结构（字段写死，后面模型都靠它）

### (1) `matches`

| 列           | 类型    | 说明                             |
| ----------- | ----- | ------------------------------ |
| match_id    | int64 | 主键                             |
| patch       | int32 | OpenDota patch id（57/58/59 之类） |
| start_time  | int64 | unix                           |
| duration    | int32 | 秒                              |
| radiant_win | bool  | 结果                             |
| game_mode   | int32 | 过滤条件                           |
| lobby_type  | int32 | 过滤条件                           |
| region      | int32 | 可选                             |

### (2) `players_static`（每场10行）

| 列                                                           | 类型                          |
| ----------------------------------------------------------- | --------------------------- |
| match_id int64                                              |                             |
| slot_idx int8                                               | 把 dire 128-132 映射到 5-9（见下面） |
| team int8                                                   | 0=Radiant 1=Dire            |
| hero_id int16                                               |                             |
| lane int8, lane_role int8                                   |                             |
| rank_tier int16 (nullable), computed_mmr float32 (nullable) |                             |

> slot 映射：`slot_idx = player_slot if player_slot < 128 else player_slot - 123`

### (3) `state_player_minute`（每分钟每人一行）

| 列                                        | 类型                    | 说明 |
| ---------------------------------------- | --------------------- | -- |
| match_id int64, patch int32              |                       |    |
| t int32                                  | 秒（来自 players[].times） |    |
| slot_idx int8, team int8, hero_id int16  |                       |    |
| gold int32, xp int32, lh int16, dn int16 |                       |    |

### (4) `state_team_minute`（每分钟每场一行）

| 列                                 | 类型 |
| --------------------------------- | -- |
| match_id int64, patch int32       |    |
| t int32                           |    |
| radiant_gold_adv int32 (nullable) |    |
| radiant_xp_adv int32 (nullable)   |    |

### (5) `events`（统一事件流，训练 world model/planner 的关键）

| 列                                          | 类型                                                   | 说明 |
| ------------------------------------------ | ---------------------------------------------------- | -- |
| match_id int64, patch int32                |                                                      |    |
| t int32                                    | 秒（允许负数：开局前购买/插眼）                                     |    |
| slot_idx int8 (nullable)                   | 有些 objective 事件没有玩家                                  |    |
| team int8 (nullable)                       |                                                      |    |
| event_type string                          | 枚举：purchase/ward_obs_place/...                       |    |
| key string (nullable)                      | item名/目标名/符号等                                        |    |
| x float32 (nullable), y float32 (nullable) |                                                      |    |
| target string (nullable)                   | 如 ward_left 的 attackername / kill 的 victim hero name |    |
| fight_id int16 (nullable)                  | teamfight 相关                                         |    |

### (6) `teamfights`

| 列                           | 类型 |
| --------------------------- | -- |
| match_id int64, patch int32 |    |
| fight_id int16              |    |
| start int32, end int32      |    |
| deaths int16                |    |

> 先别搞复杂 per-fight per-player 表，Phase 1 够用了。

---

## 3.2 ETL 脚本：`aegis/etl/build_dataset.py`


运行：

```bash
python -m aegis.etl.build_dataset \
  --input data/raw/matches_parsed_7.38_7.40_v22.jsonl \
  --out_dir data/processed \
  --flush_matches 200 \
  --min_duration 600
```

---

# 4) 一分钟 sanity check（确保我们真的“可开工”）

如果你装了 duckdb：

```bash
python - <<'PY'
import duckdb
con = duckdb.connect()
print(con.execute("select count(*) from read_parquet('data/processed/matches/*.parquet')").fetchall())
print(con.execute("select patch, count(*) from read_parquet('data/processed/matches/*.parquet') group by 1 order by 2 desc").fetchall())
print(con.execute("select event_type, count(*) from read_parquet('data/processed/events/*.parquet') group by 1 order by 2 desc limit 20").fetchall())
PY
```

你应该能立刻看到：

* matches 总数（过滤后）
* patch 分布（对应你给的 7.38/7.39/7.40 数量级）
* events 里 purchase/ward/objective/teamfight 的量是否合理

---

# 5) 这一步做完以后


## 1) 先做：用 processed 的 matches 重新生成 split（覆盖原来的 txt）

原因：ETL 过滤掉了 43 场（`--min_duration 600`），所以你之前的 split 里会包含少量“不存在于 processed”的 match_id。我们直接基于 processed 重建 split，让它 **100%一致**。

```bash
python -m aegis.etl.make_splits_from_processed \
  --test_patch 59 --val_patch 58 --val_frac 0.1
```

跑完后，`data/splits/test.txt` 应该变成 **4843**（和 processed 的 patch59 一致）。

### （可选）快速验一下 split 是否全都存在

```bash
python - <<'PY'
import duckdb
con=duckdb.connect()
missing = con.execute("""
WITH s AS (
  SELECT CAST(column0 AS BIGINT) AS match_id
  FROM read_csv_auto('data/splits/test.txt', header=False)
),
m AS (
  SELECT match_id FROM read_parquet('data/processed/matches/*.parquet')
)
SELECT COUNT(*) FROM s LEFT JOIN m USING(match_id) WHERE m.match_id IS NULL;
""").fetchone()[0]
print("missing_in_processed(test):", missing)
PY
```

输出应该是 `0`。
